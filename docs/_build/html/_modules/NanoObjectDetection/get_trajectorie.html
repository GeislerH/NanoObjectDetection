
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>NanoObjectDetection.get_trajectorie &#8212; NanoObjectDetection  documentation</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">NanoObjectDetection  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for NanoObjectDetection.get_trajectorie</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Tue Feb  5 12:23:39 2019</span>

<span class="sd">@author: Ronny Förster und Stefan Weidlich</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="c1"># In[0]:</span>
<span class="c1"># coding: utf-8</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Analyzis of Gold-Particle data for ARHCF paper</span>

<span class="sd">Created on 20181001 by Stefan Weidlich (SW)</span>
<span class="sd">Based on previous skript of Ronny Förster (RF) and SW</span>

<span class="sd">Target here: Implement only routines as they&#39;ll be used in paper</span>

<span class="sd">Modifications:</span>
<span class="sd">181020, SW: Cleaning up of code</span>
<span class="sd">Amongst others: Python v3.5 implementation deleted. Now working with 3.6 and above only</span>
<span class="sd">181025, SW: Adjustment of tracking-parameters and structuring of header</span>
<span class="sd">--&gt; Realized that 32-bit parameters for tracking lead to unsufficient pixel-precision for 64 bit-version</span>
<span class="sd">181026, SW: Taking out of log-tracking. --&gt; Not needed</span>

<span class="sd">******************************************************************************</span>
<span class="sd">Importing neccessary libraries</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#from __future__ import division, unicode_literals, print_function # For compatibility with Python 2 and 3</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> <span class="c1"># Library for array-manipulation</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span> <span class="c1"># Library for DataFrame Handling</span>
<span class="kn">import</span> <span class="nn">trackpy</span> <span class="k">as</span> <span class="nn">tp</span> <span class="c1"># trackpy offers all tools needed for the analysis of diffusing particles</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">NanoObjectDetection</span> <span class="k">as</span> <span class="nn">nd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span> <span class="c1"># Libraries for plotting</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span> <span class="c1"># I import this entirely here, as it&#39;s needed to change colormaps</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="k">import</span> <span class="n">tqdm</span><span class="c1"># progress bar</span>

<span class="kn">from</span> <span class="nn">pdb</span> <span class="k">import</span> <span class="n">set_trace</span> <span class="k">as</span> <span class="n">bp</span> <span class="c1">#debugger</span>

<span class="c1"># In[]</span>
<span class="c1">#def OptimizeParamFindSpots(rawframes_ROI, ParameterJsonFile, SaveFig, gamma = 0.8, diameter=None , minmass=None, separation=None):</span>
<span class="c1">#    </span>
<span class="c1">#    settings = nd.handle_data.ReadJson(ParameterJsonFile)</span>
<span class="c1">#    </span>
<span class="c1">#    diameter = settings[&quot;Find&quot;][&quot;Estimated particle size&quot;]</span>
<span class="c1">#    minmass = settings[&quot;Find&quot;][&quot;Minimal bead brightness&quot;]</span>
<span class="c1">#    separation = settings[&quot;Find&quot;][&quot;Separation data&quot;]</span>
<span class="c1">#    </span>
<span class="c1">#    obj = nd.get_trajectorie.batch_np(rawframes_ROI[0:1,:,:], ParameterJsonFile, diameter = diameter,</span>
<span class="c1">#                                      minmass = minmass, separation = separation)</span>
<span class="c1">#</span>
<span class="c1">#    params, title_font, axis_font = nd.visualize.GetPlotParameters(settings)</span>
<span class="c1">#    </span>
<span class="c1">##    mpl.rcParams.update(params)</span>
<span class="c1">#    </span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#    fig = plt.figure()</span>
<span class="c1">#</span>
<span class="c1">#    plt.imshow(nd.handle_data.DispWithGamma(rawframes_ROI[0,:,:] ,gamma = gamma))</span>
<span class="c1">#</span>
<span class="c1">#    </span>
<span class="c1">#    plt.scatter(obj[&quot;x&quot;],obj[&quot;y&quot;], s = 20, facecolors=&#39;none&#39;, edgecolors=&#39;r&#39;, linewidths=0.3)</span>
<span class="c1">#</span>
<span class="c1">##    my_s = rawframes_ROI.shape[2] / 10</span>
<span class="c1">##    my_linewidths = rawframes_ROI.shape[2] / 1000</span>
<span class="c1">##    plt.scatter(obj[&quot;x&quot;],obj[&quot;y&quot;], s = my_s, facecolors=&#39;none&#39;, edgecolors=&#39;r&#39;, linewidths = my_linewidths)</span>
<span class="c1">#  </span>
<span class="c1">#</span>
<span class="c1">#    plt.title(&quot;Identified Particles in first frame&quot;, **title_font)</span>
<span class="c1">#    plt.xlabel(&quot;long. Position [Px]&quot;)</span>
<span class="c1">#    plt.ylabel(&quot;trans. Position [Px]&quot;, **axis_font)</span>
<span class="c1">#    </span>
<span class="c1">#       </span>
<span class="c1">#    if SaveFig == True:</span>
<span class="c1">#        save_folder_name = settings[&quot;Plot&quot;][&quot;SaveFolder&quot;]</span>
<span class="c1">#        save_image_name = &#39;Optimize_First_Frame&#39;</span>
<span class="c1">#</span>
<span class="c1">#        settings = nd.visualize.export(save_folder_name, save_image_name, settings, use_dpi = 300)</span>
<span class="c1">#        </span>
<span class="c1">#        # close it because its reopened anyway</span>
<span class="c1">##        plt.close(fig)</span>
<span class="c1">#    </span>
<span class="c1">#</span>
<span class="c1">#    return obj, settings</span>



<div class="viewcode-block" id="FindSpots"><a class="viewcode-back" href="../../NanoObjectDetection.html#NanoObjectDetection.get_trajectorie.FindSpots">[docs]</a><span class="k">def</span> <span class="nf">FindSpots</span><span class="p">(</span><span class="n">frames_np</span><span class="p">,</span> <span class="n">ParameterJsonFile</span><span class="p">,</span> <span class="n">UseLog</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">diameter</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">minmass</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">separation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">max_iterations</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">SaveFig</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines the paramter for the trackpy routine tp.batch, which spots particles, out of the json file</span>
<span class="sd">    </span>
<span class="sd">    important parameters:</span>
<span class="sd">    separation = settings[&quot;Find&quot;][&quot;Separation data&quot;] ... minimum distance of spotes objects</span>
<span class="sd">    minmass    = settings[&quot;Find&quot;][&quot;Minimal bead brightness&quot;]   ... minimum brightness of an object in order to be saved</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">settings</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">handle_data</span><span class="o">.</span><span class="n">ReadJson</span><span class="p">(</span><span class="n">ParameterJsonFile</span><span class="p">)</span>
    
    <span class="n">DoSimulation</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Simulation&quot;</span><span class="p">][</span><span class="s2">&quot;SimulateData&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">DoSimulation</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No data. A simulation is done instead&quot;</span><span class="p">)</span>        
        <span class="n">output</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">Simulation</span><span class="o">.</span><span class="n">PrepareRandomWalk</span><span class="p">(</span><span class="n">ParameterJsonFile</span><span class="p">)</span>       
        
    <span class="k">else</span><span class="p">:</span>
        <span class="n">UseLog</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Find&quot;</span><span class="p">][</span><span class="s2">&quot;Analyze in log&quot;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">UseLog</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">frames_np</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">handle_data</span><span class="o">.</span><span class="n">LogData</span><span class="p">(</span><span class="n">frames_np</span><span class="p">)</span>
        
        
        <span class="n">separation</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Find&quot;</span><span class="p">][</span><span class="s2">&quot;Separation data&quot;</span><span class="p">]</span>
        <span class="n">minmass</span>    <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Find&quot;</span><span class="p">][</span><span class="s2">&quot;Minimal bead brightness&quot;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">UseLog</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">diameter</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Find&quot;</span><span class="p">][</span><span class="s2">&quot;Estimated particle size&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diameter</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Find&quot;</span><span class="p">][</span><span class="s2">&quot;Estimated particle size (log-scale)&quot;</span><span class="p">]</span>
    
    
        <span class="n">output</span> <span class="o">=</span> <span class="n">tp</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="n">frames_np</span><span class="p">,</span> <span class="n">diameter</span><span class="p">,</span> <span class="n">minmass</span> <span class="o">=</span> <span class="n">minmass</span><span class="p">,</span> <span class="n">separation</span> <span class="o">=</span> <span class="n">separation</span><span class="p">,</span> <span class="n">max_iterations</span> <span class="o">=</span> <span class="n">max_iterations</span><span class="p">)</span>
       
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;abstime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;MSD&quot;</span><span class="p">][</span><span class="s2">&quot;effective_fps&quot;</span><span class="p">]</span>
     
    
        <span class="n">nd</span><span class="o">.</span><span class="n">handle_data</span><span class="o">.</span><span class="n">WriteJson</span><span class="p">(</span><span class="n">ParameterJsonFile</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span> 
    
    
        <span class="k">if</span> <span class="n">SaveFig</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">title_font</span><span class="p">,</span> <span class="n">axis_font</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">visualize</span><span class="o">.</span><span class="n">GetPlotParameters</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">nd</span><span class="o">.</span><span class="n">handle_data</span><span class="o">.</span><span class="n">DispWithGamma</span><span class="p">(</span><span class="n">rawframes_ROI</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span> <span class="p">,</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span><span class="n">output</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">facecolors</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
 
        
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Identified Particles in first frame&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">title_font</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;long. Position [Px]&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;trans. Position [Px]&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">axis_font</span><span class="p">)</span>
            <span class="n">save_folder_name</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Plot&quot;</span><span class="p">][</span><span class="s2">&quot;SaveFolder&quot;</span><span class="p">]</span>
            <span class="n">save_image_name</span> <span class="o">=</span> <span class="s1">&#39;Optimize_First_Frame&#39;</span>
    
            <span class="n">settings</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">visualize</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="n">save_folder_name</span><span class="p">,</span> <span class="n">save_image_name</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">use_dpi</span> <span class="o">=</span> <span class="mi">300</span><span class="p">)</span>
        
    
    <span class="k">return</span> <span class="n">output</span></div>




<div class="viewcode-block" id="link_df"><a class="viewcode-back" href="../../NanoObjectDetection.html#NanoObjectDetection.get_trajectorie.link_df">[docs]</a><span class="k">def</span> <span class="nf">link_df</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ParameterJsonFile</span><span class="p">,</span> <span class="n">SearchFixedParticles</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_displacement</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dark_time</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines the paramter for the trackpy routine tp.link, which forms trajectories</span>
<span class="sd">    out of particle positions, out of the json file.</span>
<span class="sd">    </span>
<span class="sd">    important parameters:</span>
<span class="sd">    SearchFixedParticles = Defines weather fixed or moving particles are under current investigation</span>
<span class="sd">    dark_time            = settings[&quot;Link&quot;][&quot;Dark time&quot;] ... maximum number of frames a particle can disappear</span>
<span class="sd">    max_displacement     = [&quot;Link&quot;][&quot;Max displacement&quot;]   ...maximum displacement between two frames</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">settings</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">handle_data</span><span class="o">.</span><span class="n">ReadJson</span><span class="p">(</span><span class="n">ParameterJsonFile</span><span class="p">)</span>
    
    <span class="n">dark_time</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Link&quot;</span><span class="p">][</span><span class="s2">&quot;Dark time&quot;</span><span class="p">]</span>
    
    
    <span class="k">if</span> <span class="n">SearchFixedParticles</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">max_displacement</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Link&quot;</span><span class="p">][</span><span class="s2">&quot;Max displacement&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">max_displacement</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Link&quot;</span><span class="p">][</span><span class="s2">&quot;Max displacement fix&quot;</span><span class="p">]</span>
    
    <span class="n">t1_orig</span> <span class="o">=</span> <span class="n">tp</span><span class="o">.</span><span class="n">link_df</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">max_displacement</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="n">dark_time</span><span class="p">)</span>
    
    <span class="n">nd</span><span class="o">.</span><span class="n">handle_data</span><span class="o">.</span><span class="n">WriteJson</span><span class="p">(</span><span class="n">ParameterJsonFile</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span> 
    
    
    <span class="k">return</span> <span class="n">t1_orig</span></div>



<div class="viewcode-block" id="filter_stubs"><a class="viewcode-back" href="../../NanoObjectDetection.html#NanoObjectDetection.get_trajectorie.filter_stubs">[docs]</a><span class="k">def</span> <span class="nf">filter_stubs</span><span class="p">(</span><span class="n">traj_all</span><span class="p">,</span> <span class="n">ParameterJsonFile</span><span class="p">,</span> <span class="n">FixedParticles</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">BeforeDriftCorrection</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">min_tracking_frames</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines the paramter for the trackpy routine tp.filter_stubs, which cuts to short trajectories,</span>
<span class="sd">    out of the json file.</span>
<span class="sd">    </span>
<span class="sd">    important parameters:</span>
<span class="sd">    FixedParticles        = Defines weather fixed or moving particles are under current investigation</span>
<span class="sd">    Fixed Particles must have long trajectories to ensure that they are really stationary</span>
<span class="sd">    </span>
<span class="sd">    BeforeDriftCorrection = Defines if the particles have been already drift corrected</span>
<span class="sd">    Before drift correction short trajectories are ok</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">settings</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">handle_data</span><span class="o">.</span><span class="n">ReadJson</span><span class="p">(</span><span class="n">ParameterJsonFile</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">FixedParticles</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">BeforeDriftCorrection</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
        <span class="c1"># stationry particles</span>
        <span class="n">min_tracking_frames</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Link&quot;</span><span class="p">][</span><span class="s2">&quot;Dwell time stationary objects&quot;</span><span class="p">]</span>
        
    <span class="k">elif</span> <span class="p">(</span><span class="n">FixedParticles</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">BeforeDriftCorrection</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
        <span class="c1"># moving particle before drift correction</span>
        <span class="n">min_tracking_frames</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Link&quot;</span><span class="p">][</span><span class="s2">&quot;Min tracking frames before drift&quot;</span><span class="p">]</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># moving particle after drift correction</span>
        <span class="n">min_tracking_frames</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Link&quot;</span><span class="p">][</span><span class="s2">&quot;Min_tracking_frames&quot;</span><span class="p">]</span>
        

    <span class="n">traj_min_length</span> <span class="o">=</span> <span class="n">tp</span><span class="o">.</span><span class="n">filter_stubs</span><span class="p">(</span><span class="n">traj_all</span><span class="p">,</span> <span class="n">min_tracking_frames</span><span class="p">)</span>

    <span class="n">particle_number</span> <span class="o">=</span> <span class="n">traj_all</span><span class="p">[</span><span class="s1">&#39;particle&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">();</span> <span class="c1">#particlue numbers that fulfill all previous requirements</span>
    <span class="n">amount_particles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">particle_number</span><span class="p">);</span> <span class="c1">#total number of valid particles</span>
    
    <span class="n">valid_particle_number</span> <span class="o">=</span> <span class="n">traj_min_length</span><span class="p">[</span><span class="s1">&#39;particle&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">();</span> <span class="c1">#particlue numbers that fulfill all previous requirements</span>
    <span class="n">amount_valid_particles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_particle_number</span><span class="p">);</span> <span class="c1">#total number of valid particles</span>
    
    
    <span class="k">if</span> <span class="p">(</span><span class="n">FixedParticles</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">BeforeDriftCorrection</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of stationary objects (might detected multiple times after beeing dark):&#39;</span><span class="p">,</span> <span class="n">amount_valid_particles</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="p">(</span><span class="n">FixedParticles</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">BeforeDriftCorrection</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;To short particles removed! Before: </span><span class="si">%d</span><span class="s2">, After = </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">amount_particles</span><span class="p">,</span><span class="n">amount_valid_particles</span><span class="p">))</span>
            
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;To short particles removed! Before: </span><span class="si">%d</span><span class="s2">, After = </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">amount_particles</span><span class="p">,</span><span class="n">amount_valid_particles</span><span class="p">))</span>

    <span class="n">nd</span><span class="o">.</span><span class="n">handle_data</span><span class="o">.</span><span class="n">WriteJson</span><span class="p">(</span><span class="n">ParameterJsonFile</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span> 
    

    <span class="k">return</span> <span class="n">traj_min_length</span></div>



<div class="viewcode-block" id="RemoveSpotsInNoGoAreas"><a class="viewcode-back" href="../../NanoObjectDetection.html#NanoObjectDetection.get_trajectorie.RemoveSpotsInNoGoAreas">[docs]</a><span class="k">def</span> <span class="nf">RemoveSpotsInNoGoAreas</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">t2_long_fix</span><span class="p">,</span> <span class="n">ParameterJsonFile</span><span class="p">,</span> <span class="n">min_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    In case of stationary/ fixed objects a moving particle should not come to close.</span>
<span class="sd">    This is because stationary objects might be very bright clusters which overshine the image of the dim</span>
<span class="sd">    moving particle. Thus a &#39;not-go-area&#39; is defined</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="n">settings</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">handle_data</span><span class="o">.</span><span class="n">ReadJson</span><span class="p">(</span><span class="n">ParameterJsonFile</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;StationaryObjects&quot;</span><span class="p">][</span><span class="s2">&quot;Analyze fixed spots&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1">#required minimum distance in pixels between moving and stationary particles</span>
        <span class="n">min_distance</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;StationaryObjects&quot;</span><span class="p">][</span><span class="s2">&quot;Min distance to stationary object&quot;</span><span class="p">]</span>
        
    
        <span class="c1"># loop through all stationary objects (cotains position (x,y) and time of existent (frame))</span>
        <span class="n">num_loop_elements</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t2_long_fix</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">loop_t1_fix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">t2_long_fix</span><span class="p">)):</span>
            <span class="n">nd</span><span class="o">.</span><span class="n">visualize</span><span class="o">.</span><span class="n">update_progress</span><span class="p">(</span><span class="s2">&quot;Remove Spots In No Go Areas&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">loop_t1_fix</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">num_loop_elements</span><span class="p">)</span>
            <span class="c1">#print(loop_t1_fix)</span>
            
            <span class="c1"># stationary object to check if it disturbs other particles</span>
            <span class="n">my_check</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span>
        
            <span class="c1"># SEMI EXPENSIVE STEP: calculate the position and time mismatch between all objects </span>
            <span class="c1"># and stationary object under investigation    </span>
            <span class="n">mydiff</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;frame&#39;</span><span class="p">]]</span> <span class="o">-</span> <span class="n">my_check</span><span class="p">[[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;frame&#39;</span><span class="p">]]</span>
            
            <span class="c1"># get the norm</span>
            <span class="c1"># THIS ALSO ACCOUNT FOR THE TIME DIMENSION!</span>
            <span class="c1"># --&gt; IF THE STATIONARY OBJECT VANISHED ITS &quot;SHADOW&quot; CAN STILL DELETE A MOVING PARTICLE</span>
            <span class="n">mynorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">mydiff</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># check for which particles the criteria of minimum distance is fulfilled</span>
            <span class="n">check_distance</span> <span class="o">=</span> <span class="n">mynorm</span> <span class="o">&gt;</span> <span class="n">min_distance</span> 
            
            <span class="c1"># keep only the good ones</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="n">check_distance</span><span class="p">]</span>
            
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!!! PARTICLES CAN ENTER NO GO AREA WITHOUT GETTING CUT !!!&quot;</span><span class="p">)</span>
        
    <span class="n">nd</span><span class="o">.</span><span class="n">handle_data</span><span class="o">.</span><span class="n">WriteJson</span><span class="p">(</span><span class="n">ParameterJsonFile</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span> 
    
        
    <span class="k">return</span> <span class="n">obj</span></div>



<div class="viewcode-block" id="close_gaps"><a class="viewcode-back" href="../../NanoObjectDetection.html#NanoObjectDetection.get_trajectorie.close_gaps">[docs]</a><span class="k">def</span> <span class="nf">close_gaps</span><span class="p">(</span><span class="n">t1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # FILL GAPS IN THE TRAJECTORY BY NEAREST NEIGHBOUR</span>
<span class="sd">    # NECESSARY FOR FOLLOWING FILTERING WHERE AGAIN A NEAREST NEIGHBOUR IS APPLIED</span>
<span class="sd">    # OTHERWISE THE MEDIAN FILL WILL JUST IGNORE MISSING TIME POINTS</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">valid_particle_number</span> <span class="o">=</span> <span class="n">t1</span><span class="p">[</span><span class="s1">&#39;particle&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">();</span> <span class="c1">#particlue numbers that fulfill all previous requirements</span>
    <span class="n">amount_valid_particles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_particle_number</span><span class="p">);</span>

    <span class="c1"># use a copy of t1</span>
    <span class="n">t1_before</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">copy</span><span class="p">();</span>
    
    <span class="c1"># SORT BY PARTICLE AND THEN BY FRAME</span>
    <span class="n">t1_search_gap</span> <span class="o">=</span> <span class="n">t1_before</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;particle&#39;</span><span class="p">,</span> <span class="s1">&#39;frame&#39;</span><span class="p">])</span>

    <span class="c1">#t1_search_gap.head()</span>
    
    <span class="c1">#fill the gaps now - get the header</span>
    <span class="n">t1_gapless</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="n">t1_search_gap</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>           
            
    <span class="c1">#for loop_particle in range(0,int(num_last_particles)):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loop_particle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">valid_particle_number</span><span class="p">):</span>
        <span class="n">nd</span><span class="o">.</span><span class="n">visualize</span><span class="o">.</span><span class="n">update_progress</span><span class="p">(</span><span class="s2">&quot;Close gaps in trajectories&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">amount_valid_particles</span><span class="p">)</span>
    
        <span class="c1">#grab values for specific particle</span>
        <span class="n">t1_loop</span> <span class="o">=</span> <span class="n">t1_search_gap</span><span class="p">[</span><span class="n">t1_search_gap</span><span class="o">.</span><span class="n">particle</span> <span class="o">==</span> <span class="n">loop_particle</span><span class="p">]</span>
        <span class="c1"># read number of detected frames</span>
        <span class="n">num_catched_frames</span> <span class="o">=</span> <span class="n">t1_loop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># check if particle is not empty</span>
        <span class="k">if</span> <span class="n">num_catched_frames</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># calculate possible number of frames</span>
            <span class="n">start_frame</span> <span class="o">=</span> <span class="n">t1_loop</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">end_frame</span> <span class="o">=</span> <span class="n">t1_loop</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="c1">#        start_frame = t1_loop.frame_as_column.min()</span>
    <span class="c1">#        end_frame = t1_loop.frame_as_column.max()</span>
            <span class="n">num_frames</span> <span class="o">=</span> <span class="n">end_frame</span> <span class="o">-</span> <span class="n">start_frame</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># check if frames are missing</span>
            <span class="k">if</span> <span class="n">num_catched_frames</span> <span class="o">&lt;</span> <span class="n">num_frames</span><span class="p">:</span>
                <span class="c1"># insert missing indicies by nearest neighbur</span>
                <span class="n">index_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start_frame</span><span class="p">,</span> <span class="n">end_frame</span><span class="p">,</span> <span class="n">num_frames</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
                <span class="n">t1_loop</span> <span class="o">=</span> <span class="n">t1_loop</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index_frames</span><span class="p">)</span>
<span class="c1">#               </span>
<span class="c1">#                t1_loop[&quot;measured&quot;] = True</span>
<span class="c1">#                t1_loop.loc[np.isnan(t1_loop[&quot;particle&quot;]), &quot;measured&quot;] = False</span>
                
                <span class="n">t1_loop</span> <span class="o">=</span> <span class="n">t1_loop</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
                
            <span class="c1"># cat not data frame together</span>
            <span class="n">t1_gapless</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">t1_gapless</span><span class="p">,</span> <span class="n">t1_loop</span><span class="p">])</span>
            
            
    <span class="k">return</span> <span class="n">t1_gapless</span></div>




<div class="viewcode-block" id="calc_intensity_fluctuations"><a class="viewcode-back" href="../../NanoObjectDetection.html#NanoObjectDetection.get_trajectorie.calc_intensity_fluctuations">[docs]</a><span class="k">def</span> <span class="nf">calc_intensity_fluctuations</span><span class="p">(</span><span class="n">t1_gapless</span><span class="p">,</span> <span class="n">ParameterJsonFile</span><span class="p">,</span> <span class="n">dark_time</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">PlotIntMedianFit</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">PlotIntFlucPerBead</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the intensity fluctuation of a particle along its trajectory</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">settings</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">handle_data</span><span class="o">.</span><span class="n">ReadJson</span><span class="p">(</span><span class="n">ParameterJsonFile</span><span class="p">)</span>
    
    <span class="n">dark_time</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Link&quot;</span><span class="p">][</span><span class="s2">&quot;Dark time&quot;</span><span class="p">]</span>
    
    <span class="c1"># MEDIAN FILTER OF MASS</span>
    <span class="c1"># CALCULATE RELATIVE STEP HEIGHTS OVER TIME</span>
    
    <span class="c1"># rolling median filter</span>
    <span class="c1"># NOT VERY ACCURATE BUT DOES IT FOR THE MOMENT.</span>
    <span class="n">rolling_median_filter</span> <span class="o">=</span> <span class="n">t1_gapless</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;particle&#39;</span><span class="p">)[</span><span class="s1">&#39;mass&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dark_time</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>
    
    <span class="c1"># get it back to old format</span>
    <span class="n">rolling_median_filter</span> <span class="o">=</span> <span class="n">rolling_median_filter</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
    <span class="n">rolling_median_filter</span> <span class="o">=</span> <span class="n">rolling_median_filter</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s1">&#39;particle&#39;</span><span class="p">)</span>
    
    <span class="c1"># insert median filtered mass in original data frame</span>
    <span class="n">t1_gapless</span><span class="p">[</span><span class="s1">&#39;mass_smooth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rolling_median_filter</span><span class="p">[</span><span class="s1">&#39;mass&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    
    <span class="c1"># CALC DIFFERENCE</span>
    <span class="n">my_diff</span> <span class="o">=</span> <span class="n">t1_gapless</span><span class="p">[[</span><span class="s1">&#39;particle&#39;</span><span class="p">,</span><span class="s1">&#39;mass_smooth&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span>
    
       
    <span class="c1"># remove gap if NaN</span>
    <span class="n">my_diff</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">my_diff</span><span class="p">[</span><span class="s1">&#39;particle&#39;</span><span class="p">]),</span><span class="s1">&#39;mass_smooth&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span> <span class="c1"># RF 180906</span>
    
    <span class="c1"># remove gap when new particle is occurs </span>
    <span class="n">my_diff</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">my_diff</span><span class="p">[</span><span class="s1">&#39;particle&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">,</span><span class="s1">&#39;mass_smooth&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span> <span class="c1"># RF 180906    </span>
    
    <span class="c1"># remove NaN when median filter is to close on the edge defined by dark time in the median filter</span>
    <span class="n">my_diff</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">my_diff</span><span class="p">[</span><span class="s1">&#39;mass_smooth&#39;</span><span class="p">]),</span><span class="s1">&#39;mass_smooth&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span> <span class="c1"># RF 180906</span>
    
    
    <span class="c1"># relative step is median smoothed difference over its value</span>
    <span class="c1">#t1_search_gap_filled[&#39;rel_step&#39;] = abs(my_diff[&#39;mass_smooth&#39;]) / t1_search_gap_filled[&#39;mass_smooth&#39;]</span>
    <span class="c1"># step height</span>
    <span class="n">my_step_height</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">my_diff</span><span class="p">[</span><span class="s1">&#39;mass_smooth&#39;</span><span class="p">])</span>
    <span class="c1"># average step offset (top + bottom )/2</span>
    <span class="n">my_step_offest</span> <span class="o">=</span> <span class="n">t1_gapless</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;particle&#39;</span><span class="p">)[</span><span class="s1">&#39;mass_smooth&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">my_step_offest</span> <span class="o">=</span> <span class="n">my_step_offest</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s1">&#39;particle&#39;</span><span class="p">)</span>
    <span class="c1"># relative step</span>
    <span class="c1">#t1_search_gap_filled[&#39;rel_step&#39;] = my_step_height / my_step_offest.mass_smooth</span>
    <span class="n">t1_gapless</span><span class="p">[</span><span class="s1">&#39;rel_step&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">my_step_height</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">my_step_offest</span><span class="o">.</span><span class="n">mass_smooth</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">PlotIntMedianFit</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">nd</span><span class="o">.</span><span class="n">visualize</span><span class="o">.</span><span class="n">IntMedianFit</span><span class="p">(</span><span class="n">t1_gapless</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">PlotIntFlucPerBead</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">nd</span><span class="o">.</span><span class="n">visualize</span><span class="o">.</span><span class="n">MaxIntFluctuationPerBead</span><span class="p">(</span><span class="n">t1_gapless</span><span class="p">)</span>

    <span class="n">nd</span><span class="o">.</span><span class="n">handle_data</span><span class="o">.</span><span class="n">WriteJson</span><span class="p">(</span><span class="n">ParameterJsonFile</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span> 

    <span class="k">return</span> <span class="n">t1_gapless</span></div>




<div class="viewcode-block" id="split_traj"><a class="viewcode-back" href="../../NanoObjectDetection.html#NanoObjectDetection.get_trajectorie.split_traj">[docs]</a><span class="k">def</span> <span class="nf">split_traj</span><span class="p">(</span><span class="n">t2_long</span><span class="p">,</span> <span class="n">t3_gapless</span><span class="p">,</span> <span class="n">ParameterJsonFile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define settings for split trajectory at high intensity jumps</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">settings</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">handle_data</span><span class="o">.</span><span class="n">ReadJson</span><span class="p">(</span><span class="n">ParameterJsonFile</span><span class="p">)</span>
    
    <span class="n">t4_cutted</span><span class="p">,</span> <span class="n">settings</span> <span class="o">=</span> <span class="n">split_traj_at_high_steps</span><span class="p">(</span><span class="n">t2_long</span><span class="p">,</span> <span class="n">t3_gapless</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
    
    <span class="n">nd</span><span class="o">.</span><span class="n">handle_data</span><span class="o">.</span><span class="n">WriteJson</span><span class="p">(</span><span class="n">ParameterJsonFile</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span> 

    <span class="k">return</span> <span class="n">t4_cutted</span></div>



<div class="viewcode-block" id="split_traj_at_long_trajectorie"><a class="viewcode-back" href="../../NanoObjectDetection.html#NanoObjectDetection.get_trajectorie.split_traj_at_long_trajectorie">[docs]</a><span class="k">def</span> <span class="nf">split_traj_at_long_trajectorie</span><span class="p">(</span><span class="n">t4_cutted</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">Max_traj_length</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits trajectory if they are too long</span>
<span class="sd">    This might be usefull, to have sufficently long trajectorys all at the same length.</span>
<span class="sd">    Otherwise they have very diffent conficence intervalls</span>
<span class="sd">    E.g: 2 particles: 1: 500 frames, 2: 2000 frames</span>
<span class="sd">    particle 2 is splitted into 4 500frames</span>
<span class="sd">    </span>
<span class="sd">    Splitting of a particle is fine, because a particle can go out of focus and return later</span>
<span class="sd">    and is assigned as new particle too.</span>
<span class="sd">    </span>
<span class="sd">    Important is too look at the temporal component, thus particle 2 never exists twice</span>
<span class="sd">    &quot;&quot;&quot;</span>
   
    <span class="n">keep_tail</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Split&quot;</span><span class="p">][</span><span class="s2">&quot;Max_traj_length_keep_tail&quot;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">Max_traj_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Max_traj_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Split&quot;</span><span class="p">][</span><span class="s2">&quot;Max_traj_length&quot;</span><span class="p">])</span>
        
    <span class="n">free_particle_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">t4_cutted</span><span class="p">[</span><span class="s2">&quot;particle&quot;</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
    
<span class="c1">#    Max_traj_length = 1000</span>

    <span class="n">t4_cutted</span><span class="p">[</span><span class="s2">&quot;true_particle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t4_cutted</span><span class="p">[</span><span class="s2">&quot;particle&quot;</span><span class="p">]</span>
    
    <span class="n">traj_length</span> <span class="o">=</span> <span class="n">t4_cutted</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;particle&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">t4_cutted</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;particle&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    
    <span class="c1"># split when two times longer required</span>
    <span class="n">split_particles</span> <span class="o">=</span> <span class="n">traj_length</span> <span class="o">&gt;</span> <span class="n">Max_traj_length</span>
    
    
    <span class="n">particle_list</span> <span class="o">=</span> <span class="n">split_particles</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">split_particles</span><span class="p">]</span>
    
    <span class="n">particle_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">particle_list</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;int&#39;</span><span class="p">)</span>
    
    <span class="n">num_particle_list</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">particle_list</span><span class="p">)</span>


    <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">test_particle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">particle_list</span><span class="p">):</span>
        <span class="n">nd</span><span class="o">.</span><span class="n">visualize</span><span class="o">.</span><span class="n">update_progress</span><span class="p">(</span><span class="s2">&quot;Split to long trajectories&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_particle_list</span><span class="p">)</span>


<span class="c1">#        start_frame = t4_cutted[t4_cutted[&quot;particle&quot;] == test_particle][&quot;frame&quot;].iloc[0]</span>
<span class="c1">#        end_frame   = t4_cutted[t4_cutted[&quot;particle&quot;] == test_particle][&quot;frame&quot;].iloc[-1]</span>
       
        <span class="n">start_frame</span> <span class="o">=</span> <span class="n">t4_cutted</span><span class="p">[</span><span class="n">t4_cutted</span><span class="p">[</span><span class="s2">&quot;particle&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">test_particle</span><span class="p">][</span><span class="s2">&quot;frame&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1">#        end_frame   = t4_cutted[t4_cutted[&quot;particle&quot;] == test_particle][&quot;frame&quot;].iloc[-1]</span>
        
        
        <span class="n">traj_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t4_cutted</span><span class="p">[</span><span class="n">t4_cutted</span><span class="p">[</span><span class="s2">&quot;particle&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">test_particle</span><span class="p">])</span>
        
        
        
        <span class="k">while</span> <span class="n">traj_length</span> <span class="o">&gt;</span> <span class="n">Max_traj_length</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">traj_length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">Max_traj_length</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">keep_tail</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">start_frame</span> <span class="o">=</span> <span class="n">t4_cutted</span><span class="p">[</span><span class="n">t4_cutted</span><span class="p">[</span><span class="s2">&quot;particle&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">test_particle</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">Max_traj_length</span><span class="p">][</span><span class="s2">&quot;frame&quot;</span><span class="p">]</span>
                <span class="n">t4_cutted</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">t4_cutted</span><span class="p">[</span><span class="s2">&quot;particle&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">test_particle</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">t4_cutted</span><span class="p">[</span><span class="s2">&quot;frame&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">start_frame</span><span class="p">),</span> <span class="s2">&quot;particle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">free_particle_id</span>
    
                <span class="n">test_particle</span> <span class="o">=</span> <span class="n">free_particle_id</span>
                <span class="n">free_particle_id</span> <span class="o">=</span> <span class="n">free_particle_id</span> <span class="o">+</span> <span class="mi">1</span>
                
                <span class="n">traj_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t4_cutted</span><span class="p">[</span><span class="n">t4_cutted</span><span class="p">[</span><span class="s2">&quot;particle&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">test_particle</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
            
     
    <span class="k">if</span> <span class="n">keep_tail</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">t4_cutted</span> <span class="o">=</span> <span class="n">tp</span><span class="o">.</span><span class="n">filter_stubs</span><span class="p">(</span><span class="n">t4_cutted</span><span class="p">,</span> <span class="n">Max_traj_length</span><span class="p">)</span>

    
    <span class="k">return</span> <span class="n">t4_cutted</span></div>


<div class="viewcode-block" id="split_traj_at_high_steps"><a class="viewcode-back" href="../../NanoObjectDetection.html#NanoObjectDetection.get_trajectorie.split_traj_at_high_steps">[docs]</a><span class="k">def</span> <span class="nf">split_traj_at_high_steps</span><span class="p">(</span><span class="n">t2_long</span><span class="p">,</span> <span class="n">t3_gapless</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">max_rel_median_intensity_step</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="n">min_tracking_frames_before_drift</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">PlotTrajWhichNeedACut</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">NumParticles2Plot</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                             <span class="n">PlotAnimationFiltering</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">rawframes_ROI</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits the trajectory at high intensity jumps.</span>
<span class="sd">    This is motivated by the idea, that an intensity jump is more likely to happen because of a wrong assignment in</span>
<span class="sd">    the trajectory building routine, than a real intensity jump due to radius change (I_scatterung ~ R^6) or heavy</span>
<span class="sd">    substructures/intensity holes in the laser moder</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="n">max_rel_median_intensity_step</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Split&quot;</span><span class="p">][</span><span class="s2">&quot;Max rel median intensity step&quot;</span><span class="p">]</span>
    
    <span class="n">min_tracking_frames_before_drift</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Link&quot;</span><span class="p">][</span><span class="s2">&quot;Min tracking frames before drift&quot;</span><span class="p">]</span>
    
    
    <span class="c1"># check if threshold is exceeded</span>
    <span class="n">split_particle_at</span> <span class="o">=</span> <span class="n">t3_gapless</span><span class="p">[</span><span class="n">t3_gapless</span><span class="p">[</span><span class="s1">&#39;rel_step&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_rel_median_intensity_step</span><span class="p">]</span>
    
    <span class="c1"># get frame and particle number where threshold is broken</span>
    <span class="n">split_particle_at</span> <span class="o">=</span> <span class="n">split_particle_at</span><span class="p">[[</span><span class="s1">&#39;frame&#39;</span><span class="p">,</span><span class="s1">&#39;particle&#39;</span><span class="p">]]</span>
    <span class="c1">#split_particle_at = split_particle_at[[&#39;frame_as_column&#39;,&#39;particle&#39;]]</span>
    
    <span class="c1"># how many trajectories need splitting</span>
    <span class="n">num_split_particles</span> <span class="o">=</span> <span class="n">split_particle_at</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
    
    <span class="c1"># currently last bead. so the number of the new bead is defined and not unique</span>
    <span class="n">num_last_particle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">t3_gapless</span><span class="p">[</span><span class="s1">&#39;particle&#39;</span><span class="p">])</span> 
    <span class="c1">#num_last_particle = np.max(t1_before[&#39;particle&#39;]) </span>
    
    <span class="c1"># loop variable in case of plotting</span>
    <span class="k">if</span> <span class="n">PlotTrajWhichNeedACut</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">counter_display</span> <span class="o">=</span> <span class="mi">1</span>
    
    <span class="c1"># now split the beads at the gap into two beads</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">num_split_particles</span><span class="p">):</span>
        <span class="n">nd</span><span class="o">.</span><span class="n">visualize</span><span class="o">.</span><span class="n">update_progress</span><span class="p">(</span><span class="s2">&quot;Close gaps in trajectories&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_split_particles</span><span class="p">)</span>
        <span class="c1">#print(&#39;split trajectorie&#39;,x ,&#39;out of &#39;,num_split_particles)</span>
        
        <span class="c1"># NOW DO A PRECISE CHECK OF THE MASS</span>
        
        <span class="c1"># get index, number of particle which need splitting</span>
        <span class="c1"># and at which frame the split has to be done</span>
        <span class="n">split_particle</span> <span class="o">=</span> <span class="n">split_particle_at</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="n">particle_to_split</span> <span class="o">=</span> <span class="n">split_particle</span><span class="p">[</span><span class="s1">&#39;particle&#39;</span><span class="p">]</span>
        <span class="n">first_new_frame</span> <span class="o">=</span> <span class="n">split_particle</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span>
    <span class="c1">#    first_new_frame = split_particle[&#39;frame_as_column&#39;]</span>
        
    
        <span class="c1"># to see if there is a gap --&gt; t1_search_gap[t1_search_gap[&#39;particle&#39;]==particle_to_split][&#39;mass&#39;] </span>
        <span class="c1"># select right particle with following frames</span>
        <span class="c1"># the &quot;.at&quot; is necessary to change the value not on a copy but on t1 itself</span>
        <span class="c1"># https://stackoverflow.com/questions/13842088/set-value-for-particular-cell-in-pandas-dataframe-using-index</span>
    
       
        <span class="c1">#t1.at[((t1_before.particle == particle_to_split) &amp; (t1_before.frame &lt; first_new_frame)),&#39;particle&#39;] = num_last_particle + 1        </span>
        <span class="n">t2_long</span><span class="o">.</span><span class="n">at</span><span class="p">[((</span><span class="n">t2_long</span><span class="o">.</span><span class="n">particle</span> <span class="o">==</span> <span class="n">particle_to_split</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">t2_long</span><span class="o">.</span><span class="n">frame</span> <span class="o">&lt;</span> <span class="n">first_new_frame</span><span class="p">)),</span><span class="s1">&#39;particle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_last_particle</span> <span class="o">+</span> <span class="mi">1</span> 
    <span class="c1">#    t1.at[((t1.particle == particle_to_split) &amp; (t1.frame_as_column &lt; first_new_frame)),&#39;particle&#39;] = num_last_particle + 1 </span>
         
        <span class="c1"># num_last_particle ++</span>
        <span class="n">num_last_particle</span> <span class="o">=</span> <span class="n">num_last_particle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        
        <span class="c1"># just for visualization</span>
        <span class="k">if</span> <span class="n">PlotTrajWhichNeedACut</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>            
            <span class="k">if</span> <span class="n">counter_display</span> <span class="o">&lt;=</span> <span class="n">NumParticles2Plot</span><span class="p">:</span>
                <span class="n">counter_display</span> <span class="o">=</span> <span class="n">counter_display</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">nd</span><span class="o">.</span><span class="n">visualize</span><span class="o">.</span><span class="n">CutTrajectorieAtStep</span><span class="p">(</span><span class="n">t3_gapless</span><span class="p">,</span> <span class="n">particle_to_split</span><span class="p">,</span> <span class="n">max_rel_median_intensity_step</span><span class="p">)</span>

            
     
    <span class="c1"># get rid of too short tracks - again because some have been splitted    </span>
    <span class="c1">#t1=t1.rename(columns={&#39;frame_as_column&#39;:&#39;frame&#39;})</span>
    <span class="n">t2_long</span> <span class="o">=</span> <span class="n">tp</span><span class="o">.</span><span class="n">filter_stubs</span><span class="p">(</span><span class="n">t2_long</span><span class="p">,</span> <span class="n">min_tracking_frames_before_drift</span><span class="p">)</span> <span class="c1"># filtering out of artifacts that are seen for a short time only</span>
    <span class="c1"># the second argument is the maximum amount of frames that a particle is supposed not to be seen in order</span>
    <span class="c1"># not to be filtered out.</span>
    <span class="c1">#t1=t1.rename(columns={&#39;frame&#39;:&#39;frame_as_column&#39;})</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Trajectories with risk of wrong assignments :&#39;</span><span class="p">,</span><span class="n">t3_gapless</span><span class="p">[</span><span class="s1">&#39;particle&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Trajectories with reduced risk of wrong assignments ::&#39;</span><span class="p">,</span> <span class="n">t2_long</span><span class="p">[</span><span class="s1">&#39;particle&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">())</span>
    <span class="c1"># Compare the number of particles in the unfiltered and filtered data.</span>
    
    <span class="c1">#&#39;&#39;&#39;</span>
    <span class="c1">#wrong_particles=beads_property[beads_property[&#39;max_step&#39;] &gt; max_rel_median_intensity_step].index.get_value</span>

      
    
    <span class="k">if</span> <span class="n">PlotAnimationFiltering</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rawframes_ROI</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Insert the rawdata (rawframes_ROI)&quot;</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#  Video of particles: Showing movement and effects of filtering</span>
            <span class="c1">#------------------------------------------------------------------------------</span>
            <span class="c1">#rawframes_before_filtering=rawframes</span>
            <span class="n">nd</span><span class="o">.</span><span class="n">visualize</span><span class="o">.</span><span class="n">AnimateProcessedRawDate</span><span class="p">(</span><span class="n">rawframes_ROI</span><span class="p">,</span> <span class="n">t2_long</span><span class="p">)</span>

    <span class="n">t4_cutted</span> <span class="o">=</span> <span class="n">t2_long</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">t4_cutted</span><span class="p">,</span> <span class="n">settings</span></div>






<div class="viewcode-block" id="DriftCorrection"><a class="viewcode-back" href="../../NanoObjectDetection.html#NanoObjectDetection.get_trajectorie.DriftCorrection">[docs]</a><span class="k">def</span> <span class="nf">DriftCorrection</span><span class="p">(</span><span class="n">t_drift</span><span class="p">,</span> <span class="n">ParameterJsonFile</span><span class="p">,</span> <span class="n">Do_transversal_drift_correction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">drift_smoothing_frames</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">rolling_window_size</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">min_particle_per_block</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">min_tracking_frames</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">PlotGlobalDrift</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">PlotDriftAvgSpeed</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">PlotDriftTimeDevelopment</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                    <span class="n">PlotDriftFalseColorMapFlow</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">PlotDriftVectors</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">PlotDriftFalseColorMapSpeed</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="n">PlotDriftCorrectedTraj</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate and remove overall drift from trajectories</span>
<span class="sd">    </span>
<span class="sd">    The drift needs to be removed, because the entire movement consists of brownian motion and drift</span>
<span class="sd">    In order to measure the brownian motion, the drift needs to be calculated and subtracted</span>
<span class="sd">    </span>
<span class="sd">    There are currently three options to choose from</span>
<span class="sd">    1) No drift correction - this is dangerous. However, if just a few particles are tracked the </span>
<span class="sd">    average drift is most the particles movement and thus the trajectory vanishes!</span>
<span class="sd">    </span>
<span class="sd">    2) Global Drift</span>
<span class="sd">    Calculated the drift of all particles between neighbouring frames</span>
<span class="sd">    </span>
<span class="sd">    3) Transversal drift corretion</span>
<span class="sd">    Splits the fiber in several &quot;subfibers&quot;. Each of them is treated independent. This is motivated by the idea of laminar</span>
<span class="sd">    flow, where particles on the side have a lower current than the ones in the middle</span>
<span class="sd">    However this method requires a lot of particles and makes sense for small fiber diameters where laminar flow is</span>
<span class="sd">    significant.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">settings</span> <span class="o">=</span> <span class="n">nd</span><span class="o">.</span><span class="n">handle_data</span><span class="o">.</span><span class="n">ReadJson</span><span class="p">(</span><span class="n">ParameterJsonFile</span><span class="p">)</span>
    
    
    <span class="n">ApplyDriftCorrection</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Drift&quot;</span><span class="p">][</span><span class="s2">&quot;Apply&quot;</span><span class="p">]</span>    
    
    <span class="k">if</span> <span class="n">ApplyDriftCorrection</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">t_no_drift</span> <span class="o">=</span> <span class="n">t_drift</span>
        
    <span class="k">else</span><span class="p">:</span>
        
        <span class="n">Do_transversal_drift_correction</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Drift&quot;</span><span class="p">][</span><span class="s2">&quot;Do transversal drift correction&quot;</span><span class="p">]</span>    
        <span class="n">drift_smoothing_frames</span>          <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Drift&quot;</span><span class="p">][</span><span class="s2">&quot;Drift smoothing frames&quot;</span><span class="p">]</span>    
        <span class="n">rolling_window_size</span>             <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Drift&quot;</span><span class="p">][</span><span class="s2">&quot;Drift rolling window size&quot;</span><span class="p">]</span>    
        <span class="n">min_particle_per_block</span>          <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Drift&quot;</span><span class="p">][</span><span class="s2">&quot;Min particle per block&quot;</span><span class="p">]</span>    
        <span class="n">min_tracking_frames</span>             <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;Link&quot;</span><span class="p">][</span><span class="s2">&quot;Min_tracking_frames&quot;</span><span class="p">]</span>
        
           
    
        <span class="k">if</span> <span class="n">Do_transversal_drift_correction</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mode: global drift correction&#39;</span><span class="p">)</span>
            <span class="c1"># That&#39;s not to be used if y-depending correction (next block) is performed!</span>
            
            <span class="c1"># Attention: Strictly this might be wrong:</span>
            <span class="c1"># Drift might be different along y-positions of channel.</span>
            <span class="c1"># It might be more appropriate to divide into subareas and correct for drift individually there</span>
            <span class="c1"># That&#39;s done if Do_transversal_drift_correction==1</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">tp</span><span class="o">.</span><span class="n">compute_drift</span><span class="p">(</span><span class="n">t_drift</span><span class="p">,</span> <span class="n">drift_smoothing_frames</span><span class="p">)</span> <span class="c1"># calculate the overall drift (e.g. drift of setup or flow of particles)</span>
            <span class="n">t_no_drift</span> <span class="o">=</span> <span class="n">tp</span><span class="o">.</span><span class="n">subtract_drift</span><span class="p">(</span><span class="n">t_drift</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">d</span><span class="p">)</span> <span class="c1"># subtract overall drift from trajectories (creates new dataset)</span>
            
            <span class="k">if</span> <span class="n">PlotGlobalDrift</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">nd</span><span class="o">.</span><span class="n">visualize</span><span class="o">.</span><span class="n">PlotGlobalDrift</span><span class="p">()</span> <span class="c1"># plot the calculated drift</span>
        
        
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mode: transversal correction&#39;</span><span class="p">)</span>
            <span class="c1"># Y-Depending drift-correction</span>
            <span class="c1"># RF: Creation of y-sub-zones and calculation of drift</span>
            <span class="c1"># SW 180717: Subtraction of drift from trajectories</span>
        
            
            <span class="c1"># how many particles are needed to perform a drift correction</span>
            <span class="c1">#min_particle_per_block = 40</span>
            
        <span class="c1">#    # use blocks above and below for averaging (more particles make drift correction better)</span>
        <span class="c1">#    # e.g. 2 means y subarea itself and the two above AND below</span>
        <span class="c1">#    rolling_window_size = 5</span>
        
            <span class="n">average_over_total_block</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">rolling_window_size</span> <span class="o">+</span> <span class="mi">1</span>
              
            <span class="c1"># sort y values to have in each sub area the same amount of particles</span>
            <span class="n">all_y_sorted</span> <span class="o">=</span> <span class="n">t_drift</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">all_y_sorted</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            
            <span class="n">y_min</span> <span class="o">=</span> <span class="n">all_y_sorted</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>   <span class="c1"># min y of tracked particle</span>
            <span class="n">y_max</span> <span class="o">=</span> <span class="n">all_y_sorted</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>   <span class="c1"># max y of tracked particle</span>
            <span class="n">num_data_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_y_sorted</span><span class="p">)</span>
            
            <span class="c1"># total number of captured frames</span>
            <span class="n">num_frames</span> <span class="o">=</span> <span class="n">t_drift</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">t_drift</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
            
            <span class="c1"># this is difficult to explain</span>
            <span class="c1"># we have &gt;num_data_points&lt; data points and want to split them such, that each sub y has &gt;min_particle_per_block&lt; in it</span>
            <span class="c1"># in each frame &gt;num_frames&lt;</span>
            <span class="c1"># Because of the averaging with neighbouring areas the effective number is lifted &gt;average_over_total_block&lt;</span>
            <span class="c1">#start: distribute num_data_points over all number of frames and blocks</span>
            <span class="n">number_blocks</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_data_points</span> <span class="o">/</span> <span class="n">min_particle_per_block</span> <span class="o">/</span> <span class="n">num_frames</span> <span class="o">*</span> <span class="n">average_over_total_block</span><span class="p">)</span>
            
            
            <span class="c1">#sub_y = np.linspace(y_min,y_max,number_blocks+1)</span>
            <span class="n">sub_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">number_blocks</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">number_blocks</span><span class="p">):</span>
                <span class="n">use_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_data_points</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">number_blocks</span><span class="p">))</span>
                <span class="n">sub_y</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_y_sorted</span><span class="p">[</span><span class="n">use_index</span><span class="p">]</span>
            <span class="n">sub_y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_max</span>
            
            <span class="c1">#average y-range for later</span>
            <span class="n">y_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">sub_y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">sub_y</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mi">2</span>
            
            <span class="c1"># delete variable to start again</span>
            <span class="k">if</span> <span class="s1">&#39;calc_drift&#39;</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
                <span class="k">del</span> <span class="n">calc_drift</span> 
                <span class="k">del</span> <span class="n">total_drift</span>
                <span class="n">total_drift</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;frame&#39;</span><span class="p">])</span>
                <span class="n">calc_drift_diff</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    
            <span class="c1"># Creating a copy of t1 which will contain a new column with each values ysub-position</span>
            <span class="n">t_drift_ysub</span> <span class="o">=</span> <span class="n">t_drift</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">t_drift_ysub</span><span class="p">[</span><span class="s1">&#39;ysub&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># Defining values to nan</span>
                
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">number_blocks</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                   
                <span class="c1"># calc which subareas of y are in the rolling window.</span>
                <span class="n">sub_y_min</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">rolling_window_size</span>
                <span class="k">if</span> <span class="n">sub_y_min</span>  <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">sub_y_min</span> <span class="o">=</span> <span class="mi">0</span>
                
                <span class="n">sub_y_max</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">rolling_window_size</span>
                <span class="k">if</span> <span class="n">sub_y_max</span>  <span class="o">&gt;</span> <span class="n">number_blocks</span><span class="p">:</span>
                    <span class="n">sub_y_max</span> <span class="o">=</span> <span class="n">number_blocks</span><span class="p">;</span>
                    
                <span class="c1"># select which particles are in the current subarea</span>
                <span class="n">use_part</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_drift</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">sub_y</span><span class="p">[</span><span class="n">sub_y_min</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">t_drift</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sub_y</span><span class="p">[</span><span class="n">sub_y_max</span><span class="p">])</span>
                <span class="n">use_part_subtract</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_drift</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">sub_y</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">t_drift</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sub_y</span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> 
                
                <span class="c1"># get their indices</span>
                <span class="n">use_part_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">use_part</span><span class="p">)</span><span class="o">==</span><span class="kc">True</span><span class="p">)</span>   <span class="c1"># find index of elements true</span>
                
                <span class="c1"># WHAT IS THIS VARIABLE ACTUALLY GOOD FOR?</span>
                <span class="n">use_part_subtract_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">use_part_subtract</span><span class="p">)</span><span class="o">==</span><span class="kc">True</span><span class="p">)</span>
                
                <span class="c1"># Writing x as ysub into copy of t1. That&#39;s needed to treat data differently depending on y-sub-position</span>
                <span class="c1"># Python 3.5 t1_ysub[&#39;ysub&#39;].iloc[use_part_subtract_index]=x # I believe that&#39;s not an elegant way of doing it. Maybe find a better approach       </span>
                <span class="n">t_drift_ysub</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">use_part</span><span class="p">,</span><span class="s1">&#39;ysub&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="c1"># RF 180906</span>
                
        
                
                <span class="c1"># how many particles are in each frames</span>
                <span class="n">use_part_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">use_part_index</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">use_part_subtract_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">use_part_subtract_index</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">num_particles_block</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">use_part_index</span><span class="p">)</span>
                    
                <span class="c1"># check if drift_smoothing_frames is not longer than the video is long</span>
                <span class="n">num_frames</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;ROI&quot;</span><span class="p">][</span><span class="s2">&quot;frame_max&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">settings</span><span class="p">[</span><span class="s2">&quot;ROI&quot;</span><span class="p">][</span><span class="s2">&quot;frame_min&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">num_frames</span> <span class="o">&lt;</span> <span class="n">drift_smoothing_frames</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Number of frames is smaller than drift_smoothing_frames&quot;</span><span class="p">)</span>
    
    <span class="c1">#            raise NameError(&#39;HiThere&#39;)</span>
                <span class="c1"># make the drift correction with the subframe</span>
                <span class="n">calc_drift_y</span> <span class="o">=</span> <span class="n">tp</span><span class="o">.</span><span class="n">compute_drift</span><span class="p">(</span><span class="n">t_drift</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">use_part_index</span><span class="p">],</span> <span class="n">drift_smoothing_frames</span><span class="p">)</span> <span class="c1"># calculate the drift of this y block</span>
                <span class="n">calc_drift_y_diff</span><span class="o">=</span><span class="n">calc_drift_y</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">calc_drift_y_diff</span><span class="p">[</span><span class="s1">&#39;ysub&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">x</span>
                    
                <span class="n">calc_drift_y</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">calc_drift_y</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
                <span class="n">calc_drift_y</span><span class="p">[</span><span class="s1">&#39;y_range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_range</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
            
                <span class="c1"># calculate entire drift with starting and end position</span>
                <span class="n">start_pos</span> <span class="o">=</span> <span class="n">calc_drift_y</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;y_range&#39;</span><span class="p">)[[</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;frame&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">0</span><span class="p">],:]</span>
                <span class="n">end_pos</span> <span class="o">=</span> <span class="n">calc_drift_y</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;y_range&#39;</span><span class="p">)[[</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;frame&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">],:]</span>
                <span class="n">my_total</span> <span class="o">=</span> <span class="n">end_pos</span> <span class="o">-</span> <span class="n">start_pos</span>
                <span class="n">my_total</span> <span class="p">[</span><span class="s1">&#39;num_particles&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_particles_block</span>
                
                <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">calc_drift</span> <span class="o">=</span> <span class="n">calc_drift_y</span>
                    <span class="n">total_drift</span> <span class="o">=</span> <span class="n">my_total</span>
                    <span class="n">calc_drift_diff</span> <span class="o">=</span> <span class="n">calc_drift_y_diff</span> <span class="c1"># that&#39;s going to be the look-up for the drift, depending on y-sub</span>
                    
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">calc_drift</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">calc_drift</span><span class="p">,</span> <span class="n">calc_drift_y</span><span class="p">])</span>  <span class="c1">#prepare additional index</span>
                    <span class="n">total_drift</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">total_drift</span><span class="p">,</span> <span class="n">my_total</span><span class="p">])</span>
                    <span class="n">calc_drift_diff</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">calc_drift_diff</span><span class="p">,</span><span class="n">calc_drift_y_diff</span><span class="p">])</span>
            
            <span class="c1"># to distinguish that we&#39;re not looking at positions but the difference of positions</span>
            <span class="n">calc_drift_diff</span><span class="o">=</span><span class="n">calc_drift_diff</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="s1">&#39;x_diff1&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="s1">&#39;y_diff1&#39;</span><span class="p">})</span> 
            
            <span class="c1"># Adding frame as a column</span>
            <span class="n">calc_drift_diff</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">calc_drift_diff</span><span class="o">.</span><span class="n">index</span> 
            
            <span class="c1"># Indexing by y-sub-area and frame</span>
            <span class="n">calc_drift_diff</span><span class="o">=</span><span class="n">calc_drift_diff</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;ysub&#39;</span><span class="p">,</span><span class="s1">&#39;frame&#39;</span><span class="p">])</span> 
            
            <span class="c1"># Adding frame as a calumn to particle data</span>
            <span class="n">t_drift_ysub</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">t_drift_ysub</span><span class="o">.</span><span class="n">index</span> 
            
            <span class="c1"># Indexing particle-data analogously to drift-lookup</span>
            <span class="n">t_drift_ysub</span><span class="o">=</span><span class="n">t_drift_ysub</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;ysub&#39;</span><span class="p">,</span><span class="s1">&#39;frame&#39;</span><span class="p">])</span> 
            
            <span class="c1"># Adding drift-lookup into particle data, using frame and ysub</span>
            <span class="n">t_drift_ysub_diff</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">t_drift_ysub</span><span class="p">,</span><span class="n">calc_drift_diff</span><span class="p">,</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">)</span> 
            
            <span class="c1"># Releasing frame from index -&gt; allows to sort easier by frame</span>
            <span class="n">t_drift_ysub_diff</span><span class="o">=</span><span class="n">t_drift_ysub_diff</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="s1">&#39;frame&#39;</span><span class="p">)</span> 
            
            <span class="n">cumsums_x</span><span class="o">=</span><span class="n">t_drift_ysub_diff</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s1">&#39;particle&#39;</span><span class="p">,</span><span class="s1">&#39;frame&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;particle&#39;</span><span class="p">)[</span><span class="s1">&#39;x_diff1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span> 
            
            <span class="c1"># Calculating particle history in x direction:</span>
            <span class="c1"># sorting by particle first, then frame, grouping then by particle and calculating the cumulative sum of displacements</span>
            <span class="n">cumsums_y</span><span class="o">=</span><span class="n">t_drift_ysub_diff</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s1">&#39;particle&#39;</span><span class="p">,</span><span class="s1">&#39;frame&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;particle&#39;</span><span class="p">)[</span><span class="s1">&#39;y_diff1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
            <span class="c1"># same in y-direction</span>
            
             <span class="c1"># Sorting particle data in the same way</span>
            <span class="n">t_no_drift_ysub_diff_sort</span><span class="o">=</span><span class="n">t_drift_ysub_diff</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s1">&#39;particle&#39;</span><span class="p">,</span><span class="s1">&#39;frame&#39;</span><span class="p">])</span>
            
             <span class="c1"># UNSICHER: + oder - ?????</span>
            <span class="n">t_no_drift_ysub_diff_sort</span><span class="p">[</span><span class="s1">&#39;x_corr&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">t_drift_ysub_diff</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s1">&#39;particle&#39;</span><span class="p">,</span><span class="s1">&#39;frame&#39;</span><span class="p">])[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">cumsums_x</span>
            
            <span class="c1"># subtracting drift-history for each particle</span>
             <span class="c1"># UNSICHER: + oder - ?????</span>
            <span class="n">t_no_drift_ysub_diff_sort</span><span class="p">[</span><span class="s1">&#39;y_corr&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">t_drift_ysub_diff</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s1">&#39;particle&#39;</span><span class="p">,</span><span class="s1">&#39;frame&#39;</span><span class="p">])[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">cumsums_y</span>
            <span class="c1"># same in y-direction</span>
            
            <span class="c1">#tm_sub=t1_ysub_diff_sort.copy()</span>
            <span class="c1"># just giving a more descriptive name to particle data</span>
            <span class="n">t_no_drift_sub</span> <span class="o">=</span> <span class="n">t_no_drift_ysub_diff_sort</span> 
            
            <span class="c1"># dropping axes that wouldn&#39;t be needed any longer</span>
            <span class="n">t_no_drift_sub</span> <span class="o">=</span> <span class="n">t_no_drift_sub</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;x_diff1&#39;</span><span class="p">,</span> <span class="s1">&#39;y_diff1&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 
            
            <span class="c1">#tm_sub=tm_sub.rename(columns={&#39;x&#39;:&#39;x&#39;, &#39;y&#39;:&#39;y&#39;}) </span>
            <span class="c1"># renaming the corrected position into original names to keep the remaining code working with it</span>
            <span class="n">t_no_drift_sub</span> <span class="o">=</span> <span class="n">t_no_drift_sub</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;x_corr&#39;</span><span class="p">:</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y_corr&#39;</span><span class="p">:</span><span class="s1">&#39;y&#39;</span><span class="p">})</span> 
            
            <span class="c1"># Bringing tm_sub back into a format that later parts of the code need to work with it</span>
            <span class="n">t_no_drift_sub_store</span><span class="o">=</span><span class="n">t_no_drift_sub</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            
            <span class="c1"># Forgetting about ysub - which isn&#39;t needed anymore - and making frame the only index again</span>
            <span class="n">t_no_drift_sub</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;frame&#39;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
            
            <span class="c1"># Sorting by frame</span>
            <span class="n">t_no_drift_sub</span><span class="o">=</span><span class="n">t_no_drift_sub</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span> 
            
            <span class="c1"># Adding frame as a column</span>
            <span class="n">t_no_drift_sub</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_no_drift_sub</span><span class="o">.</span><span class="n">index</span> 
            <span class="n">t_no_drift_sub</span> <span class="o">=</span> <span class="n">t_no_drift_sub</span><span class="p">[[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;mass&#39;</span><span class="p">,</span><span class="s1">&#39;size&#39;</span><span class="p">,</span><span class="s1">&#39;ecc&#39;</span><span class="p">,</span><span class="s1">&#39;signal&#39;</span><span class="p">,</span><span class="s1">&#39;raw_mass&#39;</span><span class="p">,</span><span class="s1">&#39;ep&#39;</span><span class="p">,</span><span class="s1">&#39;frame&#39;</span><span class="p">,</span><span class="s1">&#39;abstime&#39;</span><span class="p">,</span><span class="s1">&#39;particle&#39;</span><span class="p">]]</span> <span class="c1"># Ordering as needed later</span>
            
            <span class="c1"># Set this, if y-depending-drift-correction is to be used</span>
            <span class="n">t_no_drift</span> <span class="o">=</span> <span class="n">t_no_drift_sub</span> 
            
    <span class="c1">#        t_no_drift = tp.filter_stubs(t_no_drift, min_tracking_frames) </span>
            <span class="n">t_no_drift</span> <span class="o">=</span> <span class="n">t_no_drift</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;frame&#39;</span><span class="p">)</span>
            
            <span class="c1"># insert y_range</span>
            <span class="c1"># total_drift.index = y_range RF180906 is that needed?</span>
                
            <span class="c1"># set two new indices - first frame than y_range        </span>
            <span class="n">calc_drift</span> <span class="o">=</span> <span class="n">calc_drift</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;frame&#39;</span><span class="p">])</span>
            
            <span class="c1"># calc velocity as deviation of drift</span>
            <span class="c1"># average speed for display</span>
            <span class="n">avg_frames</span> <span class="o">=</span> <span class="mi">30</span>
            <span class="n">calc_drift</span><span class="p">[[</span><span class="s1">&#39;velocity_y&#39;</span><span class="p">,</span> <span class="s1">&#39;velocity_x&#39;</span><span class="p">,</span><span class="s1">&#39;new_y_range&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">calc_drift</span><span class="p">[[</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y_range&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">avg_frames</span><span class="p">)</span><span class="o">/</span><span class="n">avg_frames</span>
            
            
            <span class="c1"># Delete lines where new y range begins</span>
            <span class="c1"># ronny does not like python yet</span>
            <span class="n">calc_drift_copy</span> <span class="o">=</span> <span class="n">calc_drift</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">calc_drift</span><span class="p">[</span><span class="s1">&#39;new_y_range&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            
            <span class="c1"># still not...</span>
            <span class="k">del</span> <span class="n">calc_drift</span>
            <span class="n">calc_drift</span> <span class="o">=</span> <span class="n">calc_drift_copy</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">del</span> <span class="n">calc_drift_copy</span>
            
            <span class="c1"># Do some plotting of the drift stuff</span>
            
            
        <span class="k">if</span> <span class="n">PlotDriftAvgSpeed</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">nd</span><span class="o">.</span><span class="n">visualize</span><span class="o">.</span><span class="n">DriftAvgSpeed</span><span class="p">()</span>
           
        <span class="k">if</span> <span class="n">PlotDriftTimeDevelopment</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">nd</span><span class="o">.</span><span class="n">visualize</span><span class="o">.</span><span class="n">DriftTimeDevelopment</span><span class="p">()</span>  
    
        <span class="k">if</span> <span class="n">PlotDriftFalseColorMapFlow</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">nd</span><span class="o">.</span><span class="n">visualize</span><span class="o">.</span><span class="n">DriftFalseColorMapFlow</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">PlotDriftVectors</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">nd</span><span class="o">.</span><span class="n">visualize</span><span class="o">.</span><span class="n">DriftVectors</span><span class="p">()</span>
    
        <span class="k">if</span> <span class="n">PlotDriftFalseColorMapSpeed</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">nd</span><span class="o">.</span><span class="n">visualize</span><span class="o">.</span><span class="n">DriftFalseColorMapSpeed</span><span class="p">()</span>
    
        <span class="k">if</span> <span class="n">PlotDriftCorrectedTraj</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">nd</span><span class="o">.</span><span class="n">visualize</span><span class="o">.</span><span class="n">DriftCorrectedTraj</span><span class="p">()</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;drift correction --&gt; finished&#39;</span><span class="p">)</span>
        
        <span class="n">nd</span><span class="o">.</span><span class="n">handle_data</span><span class="o">.</span><span class="n">WriteJson</span><span class="p">(</span><span class="n">ParameterJsonFile</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span> 

    
    <span class="k">return</span> <span class="n">t_no_drift</span></div>
    





<span class="c1">#def batch_np(frames_np, ParameterJsonFile, UseLog = False, diameter = None, minmass=None, maxsize=None, separation=None,</span>
<span class="c1">#          noise_size=1, smoothing_size=None, threshold=None, invert=False,</span>
<span class="c1">#          percentile=64, topn=None, preprocess=True, max_iterations=10,</span>
<span class="c1">#          filter_before=None, filter_after=None, characterize=True,</span>
<span class="c1">#          engine=&#39;auto&#39;, output=None, meta=None):</span>
<span class="c1">#    &quot;&quot;&quot;Locate Gaussian-like blobs of some approximate size in a set of images.</span>
<span class="c1">#</span>
<span class="c1">#    Preprocess the image by performing a band pass and a threshold.</span>
<span class="c1">#    Locate all peaks of brightness, characterize the neighborhoods of the peaks</span>
<span class="c1">#    and take only those with given total brightness (&quot;mass&quot;). Finally,</span>
<span class="c1">#    refine the positions of each peak.</span>
<span class="c1">#</span>
<span class="c1">#    Parameters</span>
<span class="c1">#    ----------</span>
<span class="c1">#    frames_np : HERE COMES THE DIFFERENCE</span>
<span class="c1">#            NP ARRAY OF IMAGESTACK</span>
<span class="c1">#            THAT SHOULD BE MUCH FASTER THE PIMS</span>
<span class="c1">#    diameter : odd integer or tuple of odd integers</span>
<span class="c1">#        This may be a single number or a tuple giving the feature&#39;s</span>
<span class="c1">#        extent in each dimension, useful when the dimensions do not have</span>
<span class="c1">#        equal resolution (e.g. confocal microscopy). The tuple order is the</span>
<span class="c1">#        same as the image shape, conventionally (z, y, x) or (y, x). The</span>
<span class="c1">#        number(s) must be odd integers. When in doubt, round up.</span>
<span class="c1">#    minmass : float</span>
<span class="c1">#        The minimum integrated brightness.</span>
<span class="c1">#        Default is 100 for integer images and 1 for float images, but a good</span>
<span class="c1">#        value is often much higher. This is a crucial parameter for eliminating</span>
<span class="c1">#        spurious features.</span>
<span class="c1">#        .. warning:: The mass value was changed since v0.3.3</span>
<span class="c1">#    maxsize : float</span>
<span class="c1">#        maximum radius-of-gyration of brightness, default None</span>
<span class="c1">#    separation : float or tuple</span>
<span class="c1">#        Minimum separtion between features.</span>
<span class="c1">#        Default is diameter + 1. May be a tuple, see diameter for details.</span>
<span class="c1">#    noise_size : float or tuple</span>
<span class="c1">#        Width of Gaussian blurring kernel, in pixels</span>
<span class="c1">#        Default is 1. May be a tuple, see diameter for details.</span>
<span class="c1">#    smoothing_size : float or tuple</span>
<span class="c1">#        The size of the sides of the square kernel used in boxcar (rolling</span>
<span class="c1">#        average) smoothing, in pixels</span>
<span class="c1">#        Default is diameter. May be a tuple, making the kernel rectangular.</span>
<span class="c1">#    threshold : float</span>
<span class="c1">#        Clip bandpass result below this value.</span>
<span class="c1">#        Default, None, defers to default settings of the bandpass function.</span>
<span class="c1">#    invert : boolean</span>
<span class="c1">#        Set to True if features are darker than background. False by default.</span>
<span class="c1">#    percentile : float</span>
<span class="c1">#        Features must have a peak brighter than pixels in this</span>
<span class="c1">#        percentile. This helps eliminate spurious peaks.</span>
<span class="c1">#    topn : integer</span>
<span class="c1">#        Return only the N brightest features above minmass.</span>
<span class="c1">#        If None (default), return all features above minmass.</span>
<span class="c1">#    preprocess : boolean</span>
<span class="c1">#        Set to False to turn off bandpass preprocessing.</span>
<span class="c1">#    max_iterations : integer</span>
<span class="c1">#        max number of loops to refine the center of mass, default 10</span>
<span class="c1">#    filter_before : boolean</span>
<span class="c1">#        filter_before is no longer supported as it does not improve performance.</span>
<span class="c1">#    filter_after : boolean</span>
<span class="c1">#        This parameter has been deprecated: use minmass and maxsize.</span>
<span class="c1">#    characterize : boolean</span>
<span class="c1">#        Compute &quot;extras&quot;: eccentricity, signal, ep. True by default.</span>
<span class="c1">#    engine : {&#39;auto&#39;, &#39;python&#39;, &#39;numba&#39;}</span>
<span class="c1">#    output : {None, trackpy.PandasHDFStore, SomeCustomClass}</span>
<span class="c1">#        If None, return all results as one big DataFrame. Otherwise, pass</span>
<span class="c1">#        results from each frame, one at a time, to the put() method</span>
<span class="c1">#        of whatever class is specified here.</span>
<span class="c1">#    meta : filepath or file object, optional</span>
<span class="c1">#        If specified, information relevant to reproducing this batch is saved</span>
<span class="c1">#        as a YAML file, a plain-text machine- and human-readable format.</span>
<span class="c1">#        By default, this is None, and no file is saved.</span>
<span class="c1">#</span>
<span class="c1">#    Returns</span>
<span class="c1">#    -------</span>
<span class="c1">#    DataFrame([x, y, mass, size, ecc, signal])</span>
<span class="c1">#        where mass means total integrated brightness of the blob,</span>
<span class="c1">#        size means the radius of gyration of its Gaussian-like profile,</span>
<span class="c1">#        and ecc is its eccentricity (0 is circular).</span>
<span class="c1">#</span>
<span class="c1">#    See Also</span>
<span class="c1">#    --------</span>
<span class="c1">#    locate : performs location on a single image</span>
<span class="c1">#    minmass_v03_change : to convert minmass from v0.2.4 to v0.3.0</span>
<span class="c1">#    minmass_v04_change : to convert minmass from v0.3.3 to v0.4.0</span>
<span class="c1">#</span>
<span class="c1">#    Notes</span>
<span class="c1">#    -----</span>
<span class="c1">#    This is an implementation of the Crocker-Grier centroid-finding algorithm.</span>
<span class="c1">#    [1]_</span>
<span class="c1">#</span>
<span class="c1">#    Locate works with a coordinate system that has its origin at the center of</span>
<span class="c1">#    pixel (0, 0). In almost all cases this will be the topleft pixel: the</span>
<span class="c1">#    y-axis is pointing downwards.</span>
<span class="c1">#</span>
<span class="c1">#    References</span>
<span class="c1">#    ----------</span>
<span class="c1">#    .. [1] Crocker, J.C., Grier, D.G. http://dx.doi.org/10.1006/jcis.1996.0217</span>
<span class="c1">#</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    </span>
<span class="c1">#    settings = nd.handle_data.ReadJson(ParameterJsonFile)</span>
<span class="c1">#    </span>
<span class="c1">#    UseLog = settings[&quot;Find&quot;][&quot;Analyze in log&quot;]</span>
<span class="c1">#    </span>
<span class="c1">#    if UseLog == True:</span>
<span class="c1">#        frames_np = nd.handle_data.LogData(frames_np)</span>
<span class="c1">#    </span>
<span class="c1">#    </span>
<span class="c1">#    separation = settings[&quot;Find&quot;][&quot;Separation data&quot;]</span>
<span class="c1">#    minmass    = settings[&quot;Find&quot;][&quot;Minimal bead brightness&quot;]</span>
<span class="c1">#    </span>
<span class="c1">#    if UseLog == False:</span>
<span class="c1">#        diameter = settings[&quot;Find&quot;][&quot;Estimated particle size&quot;]</span>
<span class="c1">#    else:</span>
<span class="c1">#        diameter = settings[&quot;Find&quot;][&quot;Estimated particle size (log-scale)&quot;]</span>
<span class="c1">#</span>
<span class="c1">##    settings = None, diameter = None, minmass=100, maxsize=None, separation=None,</span>
<span class="c1">##          noise_size=1, smoothing_size=None, threshold=None, invert=False,</span>
<span class="c1">##          percentile=64, topn=None, preprocess=True, max_iterations=10,</span>
<span class="c1">##          filter_before=None, filter_after=None, characterize=True,</span>
<span class="c1">##          engine=&#39;auto&#39;, output=None, meta=None</span>
<span class="c1">#</span>
<span class="c1">#    all_features = []</span>
<span class="c1">#    </span>
<span class="c1">#    num_enumerate_elements = frames_np.shape[0]</span>
<span class="c1">#</span>
<span class="c1">#    for i, image in enumerate(frames_np):</span>
<span class="c1">#        nd.visualize.update_progress(&quot;Find Particles&quot;, (i+1)/num_enumerate_elements)</span>
<span class="c1">#        features = tp.locate(image, diameter, minmass, maxsize, separation,</span>
<span class="c1">#                          noise_size, smoothing_size, threshold, invert,</span>
<span class="c1">#                          percentile, topn, preprocess, max_iterations,</span>
<span class="c1">#                          filter_before, filter_after, characterize,</span>
<span class="c1">#                          engine)</span>
<span class="c1">#        if hasattr(image, &#39;frame_no&#39;) and image.frame_no is not None:</span>
<span class="c1">#            frame_no = image.frame_no</span>
<span class="c1">#            # If this works, locate created a &#39;frame&#39; column.</span>
<span class="c1">#        else:</span>
<span class="c1">#            frame_no = i</span>
<span class="c1">#            features[&#39;frame&#39;] = i  # just counting iterations</span>
<span class="c1">#            </span>
<span class="c1">#       </span>
<span class="c1">#</span>
<span class="c1">#        if len(features) == 0:</span>
<span class="c1">#            continue</span>
<span class="c1">#</span>
<span class="c1">#        if output is None:</span>
<span class="c1">#            all_features.append(features)</span>
<span class="c1">#        else:</span>
<span class="c1">#            output.put(features)</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#    if output is None:</span>
<span class="c1">#        if len(all_features) &gt; 0:</span>
<span class="c1">#            </span>
<span class="c1">#            output = pd.concat(all_features).reset_index(drop=True)</span>
<span class="c1">#        else:  # return empty DataFrame</span>
<span class="c1">#            warnings.warn(&quot;No maxima found in any frame.&quot;)</span>
<span class="c1">#            output = pd.DataFrame(columns=list(features.columns) + [&#39;frame&#39;])</span>
<span class="c1">#    </span>
<span class="c1">##    tp.subpx_bias(output)</span>
<span class="c1">#    </span>
<span class="c1">#    output[&#39;abstime&#39;] = output[&#39;frame&#39;] / settings[&quot;Exp&quot;][&quot;fps&quot;]</span>
<span class="c1"># </span>
<span class="c1">#    nd.handle_data.WriteJson(ParameterJsonFile, settings) </span>
<span class="c1">#    </span>
<span class="c1">#    return output</span>
<span class="c1"># </span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># Test</span>
<span class="c1">#for i,j in enumerate(mylist):</span>
<span class="c1">#    print(i)</span>
<span class="c1">#    time.sleep(0.1)</span>
<span class="c1">#    update_progress(&quot;Some job&quot;, i/100.0)</span>
<span class="c1">#update_progress(&quot;Some job&quot;, 1)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">NanoObjectDetection  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Author.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.4.
    </div>
  </body>
</html>